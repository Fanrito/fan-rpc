# 泛RPC-基于Vert.x的高性能RPC框架

## 基本设计（已实现）
基本角色：服务的生产者和服务的消费者

生产者启动一个web服务，然后消费者通过请求客户端发送HTTP请求来调用。

通过`请求处理器`根据客户端的请求参数来进行不同的处理、调用不同的服务和方法。

服务生产者程序维护一个`本地服务注册器`，记录服务和对应实现类的映射。

根据消费者的请求参数，请求处理器会从服务注册器中找到对应的服务实现类，并通过Java反射机制调用method方法来实现对制定方法的调用。

注意：Java对象需要序列化之后才能在网络间传输，接收到后要反序列化为Java对象（本项目基于JAVA IO实现了序列化器）

基于代理模式为消费者要调用的接口生成一个代理对象，由代理对象完成请求的响应的过程（已基于JDK自带的Proxy类实现了代理工厂，从而实现了动态代理）

![image](https://github.com/Fanrito/fan-rpc/assets/96723391/3a66e114-e1a3-42eb-83e3-1e010ed93b4b)

### 最新进展
2024.5.7 实现SPI机制加载序列化器，用户可以通过实现Serializer接口，然后通过SPI机制加载到系统中，从而实现序列化器的可扩展性

2024.5.5 目前服务的消费端已支持多种格式的配置文件（properties、yml/yaml），服务端仅支持properties格式

## 扩展设计（待实现）
### 1、服务注册发现

![image](https://github.com/Fanrito/fan-rpc/assets/96723391/7b7a5525-085d-4354-b638-a8d4182b9f9a)

#### 注册中心核心功能

1. 数据分布式存储：集中的注册信息存储、读取和共享
2. 服务注册：生产者注册服务
3. 服务发现：消费者发现服务
4. 心跳检测：定期检查服务提供者的存货状态
5. 服务注销

#### 技术选型
Etcd：GO语言实现的开源分布式键值存储系统

Etcd采用了Raft一致性算法来保证数据的一致性和可靠性，具有高可用、强一致、分布式等特点

### 2、负载均衡

### 3、容错机制
