# 泛RPC-基于Vert.x的高性能RPC框架

## 基本设计（已实现）
基本角色：服务的生产者和服务的消费者

生产者启动一个web服务，然后消费者通过请求客户端发送HTTP请求来调用。

通过`请求处理器`根据客户端的请求参数来进行不同的处理、调用不同的服务和方法。

服务生产者程序维护一个`本地服务注册器`，记录服务和对应实现类的映射。

根据消费者的请求参数，请求处理器会从服务注册器中找到对应的服务实现类，并通过Java反射机制调用method方法来实现对制定方法的调用。

注意：Java对象需要序列化之后才能在网络间传输，接收到后要反序列化为Java对象（本项目基于JAVA IO实现了序列化器）

基于代理模式为消费者要调用的接口生成一个代理对象，由代理对象完成请求的响应的过程（已基于JDK自带的Proxy类实现了代理工厂，从而实现了动态代理）

![image](https://github.com/Fanrito/fan-rpc/assets/96723391/3a66e114-e1a3-42eb-83e3-1e010ed93b4b)


## 扩展设计（待实现）
### 1、服务注册发现

![image](https://github.com/Fanrito/fan-rpc/assets/96723391/7b7a5525-085d-4354-b638-a8d4182b9f9a)

#### 注册中心核心功能

1. 数据分布式存储：集中的注册信息存储、读取和共享
2. 服务注册：生产者注册服务
3. 服务发现：消费者发现服务
4. 心跳检测：定期检查服务提供者的存货状态
5. 服务注销

#### 技术选型
Etcd：GO语言实现的开源分布式键值存储系统

Etcd采用了Raft一致性算法来保证数据的一致性和可靠性，具有高可用、强一致、分布式等特点

### 2、自定义协议
![image](https://github.com/Fanrito/fan-rpc/assets/96723391/7267a14c-bd62-4317-a50c-0c8365faee21)
魔数：作用是安全校验，防止服务器处理了非框架发来的乱七八糟的消息（类似HTTPS的安全证书）
版本号：保证请求和响应的一致性（类以HTTP协议有1.0/2.0等版本）
序列化方式：来告诉服务端和客户端如何解析数据（类似HTTP的Content--Type内容类型）
类型：标识是请求还是响应？或者是心跳检测等其他用途。（类以TTP有请求头和响应头）
状态：如果是响应，记录响应的结果（类以HTTP的200状态代码）


### 3、负载均衡
![image](https://github.com/Fanrito/fan-rpc/assets/96723391/68e5eb4b-e015-420a-b7d4-e797aafe3a7e)


### 4、容错机制
